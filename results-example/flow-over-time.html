<html>
<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
<meta charset='utf-8'>
<script src='javascript/d3.min.js'></script>
<script src='javascript/message-of-the-day.js'></script>
<title>Carbon flows compared</title>
<style>
body {
  font: sans-serif;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

path.commodity {
  fill: none;
  stroke-width: 1.5px;
}

.no_highlight path {
  stroke: grey;
  stroke-opacity: 0.1;
}

.no_highlight circle {
  fill: grey;
  fill-opacity: 0.1;
}

.highlight path {
  stroke: black;
}

.highlight circle {
  fill: black;
}

text.highlight {
  fill: black;
}

text.no_highlight {
  fill: grey;
  fill-opacity: 0.1;
}

#chart {
  margin: 20 0 20 80;
}

td.price {
  width: 80px;
  text-align: right;
}


</style>
<body>
<p>The total of:</p>
<ul id='list_of_flows'>
</ul>
<div id='chart'>
</div>
<table>
  <thead>
    <tr><td>Scenario</td><td class='price'>2010</td><td class='price'>2015</td><td class='price'>2020</td><td class='price'>2025</td><td class='price'>2030</td><td class='price'>2035</td><td class='price'>2040</td><td class='price'>2045</td><td class='price'>2050</td></tr>
  </thead>
  <tbody id='flows'>
  </tbody>
</table>
<p>By default it is the total of all the energy flowing out of these commodities or processes, unless there is no energy flowing out in which case it is the total of the energy flowing in.</p>
<script>


function linechart(width, height) {

  var margin = {top: 30, right: 75, bottom: 30, left: 50};

  var unit = "TWh/yr";

  var x = d3.scale.linear()
    .domain([2010, 2050])
    .range([0, width - margin.left - margin.right]);

  var y = d3.scale.linear()
    .domain([0,2000])
    .range([height - margin.top - margin.bottom, 0]);

  var xAxis = d3.svg.axis()
    .tickFormat(d3.format("0f"))
    .scale(x)
    .orient("bottom");

  var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

  var scenario_colors = d3.scale.category10();

  var line = d3.svg.line()
    .x(function(d) { return x(d.year); })
    .y(function(d) { return y(d.value); });

  // Don't let scenario labels get any closer than this (in pixels)
  var minimum_space_between_labels = 18;

  // This makes sure that labels don't overlap by
  // checking that they are at least minimum_space_between_labels
  // apart and, if not, shuffling them up and down.
  function ensure_labels_are_far_enough_apart(labels) {
    var i, label_position_changed, lower_label, label, y_difference;
    // CHECK: Does resorting ruin the data binding in d3?
    labels.sort(function(a,b) { return a.label_y - b.label_y; }); // Need to be in ascending order
    do {
      label_position_changed = false;
      labels.each(function(label, i) {
        if(i == 0) {
          lower_label = label;
        } else {
          y_difference = label.label_y - lower_label.label_y;
          // If labels are overlaping, nudge them apart by 2 pixels then loop again
          if(y_difference >= 0 && y_difference < minimum_space_between_labels) {
            lower_label.label_y = lower_label.label_y - 1;
            label.label_y = label.label_y + 1;
            label_position_changed = true;
          }
          lower_label = label;
        }
      });
    } while(label_position_changed);

  }

  function chart(selection) {
    selection.each(function(data) {
        if(data == undefined) { return; }

        var svg = d3.select(this).selectAll("svg").data([data]);

        // Create any new chart areas
        var new_svg = svg.enter().append("svg").append("g").attr("class", "canvas");
        new_svg.append("g").attr("class", "commodities");
        new_svg.append("g").attr("class", "x axis");
        new_svg.append("g").attr("class", "y axis");
        new_svg.append("text")
          .attr('text-anchor', "end")
          .attr('y', -17)
          .attr("class", "y_axis_label");
        
        // Update the outer dimensions.
        svg.attr("width", width)
          .attr("height", height);

        // Update the x-axis 
        svg.select(".x.axis")
          .attr("transform", "translate(0," + y.range()[0] + ")")
          .call(xAxis);

        svg.select(".y.axis")
          .call(yAxis);

        svg.select(".y_axis_label").text(unit);

        // Update the inner dimensions.
        var g = svg.select("g.canvas")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Update the scenarios
        var commodities = g.select(".commodities").selectAll("g.commodity")
          .data(Object, function(d) { return d.name; });

        commodities.enter()
          .append("g")
            .attr("class", function(d) { return "commodity "+d.name })
          .append("path")
            .attr("class", function(d) { return "commodity "+d.name })
            .attr("stroke", function(d) { return scenario_colors(d.name); });

        commodities.exit().remove()

        commodities.select("path")
          .attr("d", function(d) { return line(d.flows); });

        // Update the line markers
        var markers = commodities.selectAll("circle")
          .data(function(d) { return d.flows; });

        markers.enter().append("circle")
          .attr("r", 2)
          .attr("fill", function(d) { return scenario_colors(d.name); }); // FIXME: This picks up the wrong colour!

        markers.exit().remove();

        markers
          .attr("cx", function(d) { return x(d.year); })
          .attr("cy", function(d) { return y(d.value); });

        // Update the scenario labels
        labels = g.select(".commodities").selectAll("text.commodity")
          .data(function(commodities) { 
              commodities.forEach(function(d) {
                if(d.flows.length > 0) {
                  d.label_y = y(d.flows[d.flows.length-1].value) // The y-position of the final data point in the scenario data (assumes this is the final year)
                }
                });
              return commodities;
              }, 
              function(d) { return d.name } // Make sure we always match by name
            );

        labels.enter().append("text")
          .text(function(d) { return d.name })
          .attr("dy", 2)
          .attr("dx", 1)
          .attr("class", function(d) { return "scenario "+d.name })
          .attr("fill", function(d) { return scenario_colors(d.name); })
          .on("mouseover", function(d) { // This does the fancy higlighting as the mouse moves over the labels
              commodities
                .classed("highlight", false)
                .classed("no_highlight", true);

              labels
                .classed("highlight", false)
                .classed("no_highlight", true);

              g.selectAll("."+d.name)
                .classed("highlight", true)
                .classed("no_highlight", false); 

          }).on("mouseout", function(d) {
              labels
                .classed("highlight", false)
                .classed("no_highlight", false);

              commodities
                .classed("highlight", false)
                .classed("no_highlight", false); 
          }).on("click", function(d) {  
              window.location = "case.html#"+d.name;
          });

        
        labels.call(ensure_labels_are_far_enough_apart);

        labels
          .attr("x", x.range()[1])
          .attr("y", function(d) { return d.label_y; });

        labels.exit().remove();
    });
  };

  chart.autoscale = function(_) {
    if (!arguments.length) return autoscale;
    autoscale = _;
    return chart;
  }

  return chart; 
}

var chart_width = 800;
var chart_height = Math.ceil(chart_width * 0.5);

var chart = linechart(chart_width, chart_height);

var case_name = undefined;

var data = [];

function drawChart() {
  d3.selectAll(".case_name").text(case_name);
  
  d3.select("#chart")
    .datum(data)
    .call(chart);
};

var price_format = d3.format(",.0f");

function drawTable() {

  var rows = d3.select("tbody#flows").selectAll("tr").data(data);

  rows.enter().append("tr");

  rows.exit().remove();

  rows.attr("class", function(d) { return d.name; });

  var names = rows.selectAll("td.name").data(function(d) { return [d.name]; });

  names.enter().append("td").attr("class", "name").append("a");

  names.exit().remove();

  names.select("a")
    .attr("href", function(d) { return "case.html#"+d;})
    .text(Object);

  var flows = rows.selectAll("td.price").data(function(d) { return d.flows; });

  flows.enter().append("td").attr("class", "price");

  flows.exit().remove();

  flows.text(function(d) { return price_format(d.value) });
}

function case_loaded(case_data) {
  cases.set(case_data[0].name, case_data);
  go();
}

function go() {
  if(all_cases_loaded() & code_to_name_lookup_loaded_flag) {
    reformatCases();
    drawListOfFlows();
    drawChart();
    drawTable();
  }
}

function drawListOfFlows() {

  var list = d3.select("#list_of_flows").selectAll("li")
    .data(flows_that_we_care_about);

  list.exit().remove();

  list.enter().append("li");

  list.text(function(d) { return code_lookup(d); });

}

function all_cases_loaded() {
  return cases.size() == case_names.length;
}

var years = [2010, 2015, 2020, 2025, 2030, 2035, 2040, 2045, 2050];
var cases = d3.map();
var code_lookup = code_to_name_lookup();
var code_to_name_lookup_loaded_flag = false;

function reformatCases() {
  data = cases.values().map(function(case_data) {
      return reformat(case_data);
  });
}

function reformat(case_data) {
  var new_values = [];
  years.forEach(function(year) {
      var year_index = case_data.findIndex(function(d) { return d.year == year });
      if(year_index >= 0) {
        var year_data = case_data[year_index].flows;
        var total_flow_value = 0;
        flows_that_we_care_about.forEach(function(flow_name) {
          var flow_index = year_data.nodes.findIndex(function(n) { return n.name == flow_name });
          if(flow_index >= 0) {
            var flows_out = d3.sum(year_data.links, function(flow) { return flow.source == flow_index ? flow.value : 0 });
            var flows_in = d3.sum(year_data.links, function(flow) { return flow.target == flow_index ? flow.value : 0 });
            total_flow_value += (flows_out != 0 ? flows_out : flows_in);
          }
        });
      new_values.push({year: year, value: total_flow_value});
    }
  });
  return { name: case_data[0].name, flows: new_values };
}

function load_case(case_name) {
  d3.json(''+case_name+"/energy-flows.json", case_loaded);
}

var settings = window.location.hash.slice(1).split(';');

var case_names = settings[0].split(",");
var flows_that_we_care_about = settings[1].split(",");

case_names.forEach(load_case);

// Polyfil from http://eveloper.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex.html
if (!Array.prototype.findIndex) {
  Array.prototype.findIndex = function(predicate) {
    if (this == null) {
      throw new TypeError('Array.prototype.findIndex called on null or undefined');
    }
    if (typeof predicate !== 'function') {
      throw new TypeError('predicate must be a function');
    }
    var list = Object(this);
    var length = list.length >>> 0;
    var thisArg = arguments[1];
    var value;

    for (var i = 0; i < length; i++) {
      value = list[i];
      if (predicate.call(thisArg, value, i, list)) {
        return i;
      }
    }
    return -1;
  };

}

function code_to_name_lookup() {
  var codes = d3.map();

  d3.tsv("codes.tsv").get(function(error, rows) {
    rows.forEach(function(row) {
      codes.set(row['Code'], row['Short']);
    });
    code_to_name_lookup_loaded_flag = true;
    go();
  });

  function lookup(code) {
    var official_form = code.replace(/^(P|C)-/i, '');
    return codes.get(official_form) || official_form;
  };

  return lookup;
}

window.addEventListener("hashchange",function() { window.location.reload() });

</script>
</body>
</html>

<html>
<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
<meta charset='utf-8'>
<script src='javascript/d3.min.js'></script>
<title>Carbon prices</title>
<style>
body {
  font: 10px sans-serif;
}

div {
  margin: 0;
  paddign: 0;
}

.process_name {
  float: left;
  width: 10%;
}

.title {
  font-weight: bold;
  display: inline-block;
  text-align: center;
  width: 29%;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

path.commodity {
  fill: none;
  stroke-width: 1.5px;
}

.no_highlight path {
  stroke: grey;
  stroke-opacity: 0.1;
}

.no_highlight circle {
  fill: grey;
  fill-opacity: 0.1;
}

.highlight path {
  stroke: black;
}

.highlight circle {
  fill: black;
}

text.highlight {
  fill: black;
}

text.no_highlight {
  fill: grey;
  fill-opacity: 0.1;
}

div.instcap, div.lumpinv, div.costperunit {
  float:left;
}

div.process {
  clear: both;
}

div#controls {
  clear: both;
  font-size: larger;
}

td.price {
  text-align: right;
  width: 5em;
}

</style>
<body>
<h1>Carbon prices in scenario <span class='case_name'>A</a></h1>
<div id='chart'>
</div>
<h1>Carbon prices in £/tCO2e</h1>
<table>
  <thead>
    <tr><td>Commodity</td><td class='price'>2010</td><td class='price'>2015</td><td class='price'>2020</td><td class='price'>2025</td><td class='price'>2030</td><td class='price'>2035</td><td class='price'>2040</td><td class='price'>2045</td><td class='price'>2050</td></tr>
  </thead>
  <tbody id='prices'>
  </tbody>
</table>
<script>


function linechart(width, height) {

  var margin = {top: 30, right: 75, bottom: 30, left: 50};

  var unit = "£/tCO2e";

  var x = d3.scale.linear()
    .domain([2010, 2050])
    .range([0, width - margin.left - margin.right]);

  var y = d3.scale.linear()
    .domain([0,5000])
    .range([height - margin.top - margin.bottom, 0]);

  var xAxis = d3.svg.axis()
    .tickFormat(d3.format("0f"))
    .scale(x)
    .orient("bottom");

  var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

  var scenario_colors = d3.scale.category10();

  var line = d3.svg.line()
    .x(function(d) { return x(d.year); })
    .y(function(d) { return y(d.value); });

  // Don't let scenario labels get any closer than this (in pixels)
  var minimum_space_between_labels = 18;

  // This makes sure that labels don't overlap by
  // checking that they are at least minimum_space_between_labels
  // apart and, if not, shuffling them up and down.
  function ensure_labels_are_far_enough_apart(labels) {
    var i, label_position_changed, lower_label, label, y_difference;
    // CHECK: Does resorting ruin the data binding in d3?
    labels.sort(function(a,b) { return a.label_y - b.label_y; }); // Need to be in ascending order
    do {
      label_position_changed = false;
      labels.each(function(label, i) {
        if(i == 0) {
          lower_label = label;
        } else {
          y_difference = label.label_y - lower_label.label_y;
          // If labels are overlaping, nudge them apart by 2 pixels then loop again
          if(y_difference >= 0 && y_difference < minimum_space_between_labels) {
            lower_label.label_y = lower_label.label_y - 1;
            label.label_y = label.label_y + 1;
            label_position_changed = true;
          }
          lower_label = label;
        }
      });
    } while(label_position_changed);

  }

  function chart(selection) {
    selection.each(function(data) {
        if(data == undefined) { return; }

        var svg = d3.select(this).selectAll("svg").data([data]);

        // Create any new chart areas
        var new_svg = svg.enter().append("svg").append("g").attr("class", "canvas");
        new_svg.append("g").attr("class", "commodities");
        new_svg.append("g").attr("class", "x axis");
        new_svg.append("g").attr("class", "y axis");
        new_svg.append("text")
          .attr('text-anchor', "end")
          .attr('y', -7)
          .attr("class", "y_axis_label");
        
        // Update the outer dimensions.
        svg.attr("width", width)
          .attr("height", height);

        // Update the x-axis 
        svg.select(".x.axis")
          .attr("transform", "translate(0," + y.range()[0] + ")")
          .call(xAxis);

        svg.select(".y.axis")
          .call(yAxis);

        svg.select(".y_axis_label").text(unit);

        // Update the inner dimensions.
        var g = svg.select("g.canvas")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Update the scenarios
        var commodities = g.select(".commodities").selectAll("g.commodity")
          .data(Object, function(d) { return d.name; });

        commodities.enter()
          .append("g")
            .attr("class", function(d) { return "commodity "+d.name })
          .append("path")
            .attr("class", function(d) { return "commodity "+d.name })
            .attr("stroke", function(d) { return scenario_colors(d.name); });

        commodities.exit().remove()

        commodities.select("path")
          .attr("d", function(d) { return line(d.prices); });

        // Update the line markers
        var markers = commodities.selectAll("circle")
          .data(function(d) { return d.prices; });

        markers.enter().append("circle")
          .attr("r", 2)
          .attr("fill", function(d) { return scenario_colors(d.name); }); // FIXME: This picks up the wrong colour!

        markers.exit().remove();

        markers
          .attr("cx", function(d) { return x(d.year); })
          .attr("cy", function(d) { return y(d.value); });

        // Update the scenario labels
        labels = g.select(".commodities").selectAll("text.commodity")
          .data(function(commodities) { 
              commodities.forEach(function(d) {
                if(d.prices.length > 0) {
                  d.label_y = y(d.prices[d.prices.length-1].value) // The y-position of the final data point in the scenario data (assumes this is the final year)
                }
                });
              return commodities;
              }, 
              function(d) { return d.name } // Make sure we always match by name
            );

        labels.enter().append("text")
          .text(function(d) { return d.name })
          .attr("dy", 2)
          .attr("dx", 1)
          .attr("class", function(d) { return "scenario "+d.name })
          .attr("fill", function(d) { return scenario_colors(d.name); })
          .on("mouseover", function(d) { // This does the fancy higlighting as the mouse moves over the labels
              commodities
                .classed("highlight", false)
                .classed("no_highlight", true);

              labels
                .classed("highlight", false)
                .classed("no_highlight", true);

              g.select(".scenarios").selectAll("."+d.name)
                .classed("highlight", true)
                .classed("no_highlight", false); })

            
          .on("mouseout", function(d) {
              labels
                .classed("highlight", false)
                .classed("no_highlight", false);

              commodities
                .classed("highlight", false)
                .classed("no_highlight", false); });
        
        labels.call(ensure_labels_are_far_enough_apart);

        labels
          .attr("x", x.range()[1])
          .attr("y", function(d) { return d.label_y; });

        labels.exit().remove();
    });
  };

  chart.autoscale = function(_) {
    if (!arguments.length) return autoscale;
    autoscale = _;
    return chart;
  }

  return chart; 
}

var chart_width = 500;
var chart_height = Math.ceil(chart_width * 0.5);

var chart = linechart(chart_width, chart_height);

var case_name = undefined;

var data = [];

function drawChart() {
  d3.selectAll(".case_name").text(case_name);
  
  d3.select("#chart")
    .datum(data)
    .call(chart);
};

var price_format = d3.format(",.0f");

function drawTable() {

  var rows = d3.select("tbody#prices").selectAll("tr").data(data);

  rows.enter().append("tr");

  rows.exit().remove();

  var names = rows.selectAll("td.name").data(function(d) { return [d.name]; });

  names.enter().append("td").attr("class", "name");

  names.exit().remove();

  names.text(Object);

  var prices = rows.selectAll("td.price").data(function(d) { return d.prices; });

  prices.enter().append("td").attr("class", "price");

  prices.exit().remove();

  prices.text(function(d) { return price_format(d.value) });
}

function case_loaded(case_data) {
  data = reformat(case_data)
  drawChart();
  drawTable();
}

var years = [2010, 2015, 2020, 2025, 2030, 2035, 2040, 2045, 2050];

function reformat(case_data) {
  d = [];
  d3.map(case_data.prices).forEach(function(commodity, values) {
    values = d3.map(values);
    var new_values = [];
    years.forEach(function(year) {
      var value = values.get(""+year) || 0;
      new_values.push({year: year, value: value});
      });
    d.push({name: commodity, prices: new_values});
    });
  return d;
}

function load_case() {
  d3.json(''+case_name+"/carbon-prices.json", case_loaded);
}

case_name = window.location.hash.slice(1).split(',')[0];
load_case();
	

</script>
</body>
</html>
